using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Project_Maze
{
    class Program
    {
        static void paintBorder(char c)
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.Write(c);
        }

        static void paintWall(char c)
        {
            Console.ForegroundColor = ConsoleColor.Gray;
            Console.Write(c);
        }

        static void paintRoad(char c)
        {
            Console.ForegroundColor = ConsoleColor.Red;
            Console.Write(c);
        }

        static bool isSafe(char[,] maze, int x, int y)
        {
            if (x >= 1 && y >= 1 && x <= 30 && y <= 30 && maze[x, y] == '0')
                return true;
            return false;
        }

        static void printMaze(char[,] maze)
        {
            for (int i = 0; i < 32; i++)
            {
                for (int j = 0; j < 32; j++)
                {
                    //Console.SetCursorPosition(20 + j, 1 + i);
                    if (maze[i, j] == '║' || maze[i, j] == '╚' || maze[i, j] == '╔' || maze[i, j] == '╝' || maze[i, j] == '═' || maze[i, j] == '╗')
                        paintBorder(maze[i, j]);
                    else if (maze[i, j] == '1')
                        paintRoad(maze[i, j]);
                    else
                        paintWall(maze[i, j]);
                }
                Console.WriteLine();
            }
        }

        static void road(char[,] maze, int x, int y, int xEnd, int yEnd, List<Step> roadTemp, List<Road> roads)
        {
            
            if (x == xEnd && y == yEnd)            
            {
                Step r = new Step();
                r.PositionX = x;
                r.PositionY = y;
                roadTemp.Add(r);
                Road nuevo = new Road();
                List<Step> nuevaLista = new List<Step>();
                foreach (Step s in roadTemp)
                {
                    Step stp = s;
                    nuevaLista.Add(stp);
                }
                nuevo.Steps = nuevaLista;
                roads.Add(nuevo);
                
                roadTemp.Remove(r);
                
                Console.WriteLine("llego al fin");
                printMaze(maze);
            }
            else
            {
                for (int i = 0; i < 4; i++)
                {
                    Step r = new Step();
                    switch (i)
                    {
                        case 0:
                            if (isSafe(maze, x, y + 1))
                            {
                                maze[x, y + 1] = '1';
                                r.PositionX = x;
                                r.PositionY = y + 1;
                                roadTemp.Add(r);
                                road(maze, x, y + 1, xEnd, yEnd, roadTemp, roads);
                                roadTemp.Remove(r);
                                maze[x, y + 1] = '0';
                            }
                            break;
                        case 1:
                            if (isSafe(maze, x + 1, y))
                            {
                                maze[x + 1, y] = '1';
                                r.PositionX = x + 1;
                                r.PositionY = y;
                                roadTemp.Add(r);
                                road(maze, x + 1, y, xEnd, yEnd, roadTemp, roads);
                                roadTemp.Remove(r);
                                maze[x + 1, y] = '0';
                            }
                            break;

                        case 2:
                            if (isSafe(maze, x, y - 1))
                            {                                
                                maze[x, y - 1] = '1';
                                r.PositionX = x;
                                r.PositionY = y - 1;
                                roadTemp.Add(r);
                                road(maze, x, y - 1, xEnd, yEnd, roadTemp, roads);
                                roadTemp.Remove(r);
                                maze[x, y - 1] = '0';
                            }
                            break;
                        case 3:
                            if (isSafe(maze, x - 1, y))
                            {
                                r.PositionX = x - 1;
                                r.PositionY = y;
                                roadTemp.Add(r);
                                maze[x - 1, y] = '1';
                                road(maze, x - 1, y, xEnd, yEnd, roadTemp, roads);
                                roadTemp.Remove(r);
                                maze[x - 1, y] = '0';
                            }
                            break;
                    }
                }
            }
        }



        static void Main(string[] args)
        {
            int[] numberSteps = new int[4] { 0, 0, 0, 0 };
            int solutionNumberSteps = 0, c = 0;
            List<Road> roads = new List<Road>();
            List<Step> roadTemp = new List<Step>();
            char[,] maze = new char[32, 32]
            {
                {'╔','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','╗'},
                {'║','0','0','0','█','█','█','0','0','0','0','0','0','0','0','0','0','0','0','█','█','█','█','█','█','█','█','█','0','0','0','║'},
                {'║','█','█','0','0','0','0','0','█','█','█','█','█','█','█','█','█','█','0','0','0','0','0','0','0','0','0','█','0','█','0','║' },
                {'║','█','█','0','█','█','█','█','█','█','█','█','█','█','█','█','█','█','0','█','█','█','█','█','█','█','0','█','0','█','0','║' },
                {'║','█','█','0','█','0','0','0','█','0','0','0','█','█','0','0','0','0','0','0','0','0','0','0','█','█','0','█','0','0','0','║' },
                {'║','█','0','0','█','0','0','0','█','0','█','0','█','█','0','█','█','█','█','█','█','█','█','0','█','█','0','█','0','█','█','║' },
                {'║','█','0','█','█','0','█','0','█','0','█','0','0','0','0','█','0','█','0','0','0','█','█','0','█','█','0','█','0','█','█','║' },
                {'║','█','0','█','0','0','█','0','█','0','█','█','█','█','█','█','0','█','0','█','0','█','█','0','█','█','0','█','0','█','█','║' },
                {'║','█','0','█','0','█','█','0','█','0','█','█','█','█','█','0','0','█','0','█','0','█','█','0','█','█','0','█','0','█','█','║' },
                {'║','█','0','█','0','0','0','0','█','0','0','0','0','0','█','█','0','█','0','█','0','0','0','0','█','█','0','█','0','█','█','║' },
                {'║','█','0','█','█','█','█','█','█','█','█','█','█','0','█','█','█','█','0','█','█','█','█','█','█','█','0','█','0','0','0','║' },
                {'║','█','0','0','0','0','0','0','█','0','0','0','█','0','█','█','0','0','0','█','0','0','0','0','█','0','0','█','0','█','0','║' },
                {'║','█','█','█','█','█','█','0','█','0','█','0','█','0','█','█','0','█','█','█','█','█','█','█','█','0','█','0','0','█','0','║' },
                {'║','█','█','█','█','█','█','0','█','0','0','0','█','0','█','█','0','0','0','0','0','0','0','█','█','0','█','█','█','█','█','║' },
                {'║','0','0','0','0','0','0','0','█','█','█','█','█','0','█','█','█','█','█','█','█','█','0','█','█','0','0','0','0','0','█','║' },
                {'║','0','█','█','█','█','█','█','█','█','0','0','0','0','█','0','0','0','0','█','0','0','0','█','█','█','█','█','█','0','█','║' },
                {'║','0','█','0','0','0','0','0','0','█','0','█','█','█','█','█','█','█','0','█','0','█','█','█','█','█','█','█','█','0','█','║' },
                {'║','0','█','0','0','0','0','0','0','█','0','0','0','0','0','0','0','█','0','█','0','0','0','0','0','0','0','█','█','0','█','║' },
                {'║','0','█','0','█','█','█','█','█','█','█','█','█','█','█','█','0','█','0','█','█','█','█','█','█','█','0','█','█','0','█','║' },
                {'║','0','█','0','█','0','0','0','0','█','0','0','0','0','0','█','0','█','█','█','█','█','█','█','█','█','0','█','█','0','█','║' },
                {'║','0','█','█','█','0','█','█','0','█','0','█','█','█','0','█','0','0','0','0','0','0','0','0','█','█','0','█','█','0','█','║' },
                {'║','0','0','0','0','0','█','█','0','█','0','█','0','0','0','█','█','█','█','█','█','█','█','0','█','█','0','█','█','0','█','║' },
                {'║','█','█','█','█','█','█','█','0','█','0','█','0','█','█','█','█','█','█','█','█','█','█','0','█','█','0','0','0','0','█','║' },
                {'║','█','0','0','█','0','0','0','0','█','0','█','0','█','0','0','0','0','0','0','0','█','█','0','█','█','█','█','█','0','█','║' },
                {'║','█','0','0','█','0','█','█','█','█','0','█','0','█','0','█','█','█','█','█','0','█','█','0','0','0','█','█','█','0','0','║' },
                {'║','█','0','0','█','0','█','0','0','0','0','█','0','█','0','█','█','█','█','█','0','█','█','█','█','0','0','█','█','█','0','║' },
                {'║','█','0','█','█','0','█','0','█','█','█','█','0','█','0','0','0','0','█','█','0','█','█','0','█','█','0','0','█','█','0','║' },
                {'║','█','0','█','0','0','█','0','0','0','0','0','0','█','█','█','█','0','█','█','0','█','█','0','0','█','█','0','0','0','0','║' },
                {'║','█','0','█','0','█','█','█','█','█','█','█','█','█','0','0','█','0','█','█','0','█','█','█','█','0','█','█','█','█','0','║' },
                {'║','█','0','█','0','0','0','0','0','0','0','0','0','0','█','█','█','0','█','█','0','0','0','0','█','█','█','█','█','█','0','║' },
                {'║','█','█','█','█','█','█','█','█','█','█','█','█','0','0','0','0','0','█','█','█','█','█','0','0','0','0','0','0','0','0','║' },
                {'╚','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','═','╝' }
            };


            maze[1, 1] = '1';

            road(maze, 1, 1, 30, 30, roadTemp, roads);

            foreach(Road r in roads)
            {
                if (c == 0)
                    solutionNumberSteps = r.Steps.Count();
                else
                {
                    if (r.Steps.Count() < solutionNumberSteps)
                        solutionNumberSteps = r.Steps.Count();
                }
                c++;
                Console.WriteLine("Cantidad : " + r.Steps.Count());
            }
            Console.WriteLine();
            Console.WriteLine("El mas optimo es : " + solutionNumberSteps);
            Console.ReadKey();

        }
    }
}
